#!/usr/bin/python

from __future__ import division
from __future__ import with_statement

import ConfigParser
import os
import re
import socket
import subprocess
import sys
import traceback
import urlparse

def call (*args, **kwargs):
    print '>', ' '.join (args)

    kwargs['stdout'] = subprocess.PIPE
    kwargs['stderr'] = subprocess.STDOUT
    kwargs['close_fds'] = True
    p = subprocess.Popen (args, **kwargs)

    so, se = p.communicate ()
    for line in so.split ('\n'):
        if line!='': print '|', line
    if p.returncode != 0:
        raise Exception ('%s failed (status %i)' % (args[0], p.returncode))

    return so

class mount (object):
    mount_output = re.compile ('(\S+) on (\S+) type (\S+) (\S+)')

    def __init__ (self, device, target = None, options = {}):
        self.device = device
        self.options = options
        self.target = target

    def check_mounted (self, desired):
        if os.path.ismount (self.target) != desired:
            raise Exception ('"%s" %s mounted, but it %s be' % (self.target, 'is not' if desired else 'is', 'should' if desired else 'should not'))

    def __enter__ (self):
        if self.target:
            self.check_mounted (False)

        args = ['mount']
        if not self.target:
            args.append ('-v')
        if len (self.options) > 0:
            args.append ('-o')
            args.append (','.join ([k + ('=' + v if v else '') for k, v in self.options.items()]))
        args.append (self.device)
        if self.target:
            args.append (self.target)

        output = call (*args)
        if not self.target:
            m = self.mount_output.match (output)
            if not m: raise Exception ('Could not parse mount output')
            self.target = m.group (2)

        self.check_mounted (True)
        return self

    def df (self):
        self.check_mounted (True)

        s = os.statvfs (self.target)
        size = s.f_frsize * s.f_blocks
        used = size - s.f_frsize * s.f_bfree
        frac = used/size * 100
        return used, size, frac

    def __exit__ (self, exc_type, exc_val, exc_tb):
        self.check_mounted (True)
        call ('umount', self.target)
        self.check_mounted (False)
        return False

class ftp_mount (object):
    def __enter__ (self):
        return self
    def __exit__ (self, exc_type, exc_val, exc_tb):
        return False
    def df (self):
        return 0, 0, 0

class snapshot (object):
    def __init__ (self, lv):
        self.lv = lv
        self.lv_snap = '%s_backup' % (lv)
        self.device = os.path.join ('/dev', self.lv_snap)

    def __enter__ (self):
        call ('lvcreate', '--quiet', '--size=1G', '--snapshot', '--name=%s' % (self.lv_snap), self.lv)

        return self

    def __exit__ (self, exc_type, exc_val, exc_tv):
        call ('lvremove', '--quiet', '--force', self.lv_snap)

        return False

def backup_dir (name, dir):
    args = ['duplicity',
        '--exclude-other-filesystems']

    if backup_type == 'auto':
        args.extend (['--full-if-older-than', '1W'])
    elif backup_type in ['full', 'incremental']:
        args.append (backup_type)
    elif backup_type == 'dummy':
        args.insert (0, 'true')

    uri = config.get ('target', 'uri')
    if uri[-1] != '/': uri += '/'
    args.extend ([dir, urlparse.urljoin (uri, name)])
    call (*args)

def backup_lv (name, lv):
    with snapshot (lv) as s:
        with mount (s.device, config.get ('lvm', 'snapshot_mnt'), {'ro': None}):
            backup_dir (name, config.get ('lvm', 'snapshot_mnt'))

backup_functions = {
    'lv': backup_lv,
    'dir': backup_dir
}

def print_line (msg):
    print '_____ %s %s' % (msg, '_' * (67 - len (msg) - 1))

if __name__ == '__main__':
    backup_types = ['auto', 'full', 'incremental', 'dummy']
    if (len (sys.argv) != 3):
        print >> sys.stderr, "Usage: %s CONFIGFILE %s" % (sys.argv[0], '|'.join (backup_types))
        sys.exit (1)

    config = ConfigParser.SafeConfigParser ({'hostname': socket.gethostname ()})
    config.read (sys.argv[1])

    # duplicity reads this from the environment
    for name, value in config.items ('environment'):
        os.environ[name] = value

    # full or incremental?
    backup_type = sys.argv[2]
    if sys.argv[2] not in backup_types:
        print 'Invalid backup type "%s"; aborting.' % (sys.argv[2])
        sys.exit (1)

    if config.has_option ('target', 'mount'):
        mounter = mount (config.get ('target', 'mount'))
    else:
        mounter = ftp_mount ()

    errors = 0

    with mounter:
        job_re = re.compile ('^job:(?P<name>\w+)$')
        for section in config.sections ():
            m = job_re.match (section)
            if not m: continue

            name = m.group ('name')
            print; print_line ("%s start" % (name))

            try:
                type = config.get (section, 'type')
                what = config.get (section, 'what')
                if type not in backup_functions:
                    raise Exception ('Unknown job type "%s"' % (type))
                backup_functions[type] (name, what)
            except Exception, e:
                errors += 1
                traceback.print_exc ()
            print_line ("%s end" % (name))

        # report
        print
        print 'Process complete.'

        if errors > 0:
            print '%i job%s failed.' % (errors, errors != 1 and 's' or '')

        used, size, frac = mounter.df ()
        print 'Used %d of %g bytes (%.0f%%).' % (used, size, frac)
        print

    sys.exit (0 if errors == 0 else 1)
