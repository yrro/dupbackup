#!/usr/bin/python

from __future__ import division
from __future__ import with_statement

import ConfigParser
import os
import re
import socket
import subprocess
import sys
import traceback
import urlparse

def call (*args, **kwargs):
    print '>', ' '.join (args)

    kwargs['stdout'] = subprocess.PIPE
    kwargs['stderr'] = subprocess.STDOUT
    kwargs['close_fds'] = True
    p = subprocess.Popen (args, **kwargs)

    so, se = p.communicate ()
    for line in so.split ('\n'):
        if line!='': print '|', line
    if p.returncode != 0:
        raise Exception ('%s failed (status %i)' % (args[0], p.returncode))

class mount (object):
    def __init__ (self, device, target, ro, options = None):
        self.device = device
        self.target = target
        self.options = 'ro' if ro else 'rw'
        if not options is None:
            self.options += ',' + options

        if os.path.ismount (target):
            raise Exception ('"%s" already mounted' % (target))

    def __enter__ (self):
        call ('mount',
            '-o',
            self.options,
            self.device,
            self.target)

        return self

    def __exit__ (self, exc_type, exc_val, exc_tb):
        if not os.path.ismount (self.target):
            raise Exception ('"%s" no longer mounted' % (self.target))
        call ('umount', self.target)

        return False

class snapshot (object):
    def __init__ (self, lv):
        self.lv = lv
        self.lv_snap = '%s_backup' % (lv)
        self.device = os.path.join ('/dev', self.lv_snap)

    def __enter__ (self):
        call ('lvcreate', '--quiet', '--size=1G', '--snapshot', '--name=%s' % (self.lv_snap), self.lv)

        return self

    def __exit__ (self, exc_type, exc_val, exc_tv):
        call ('lvremove', '--quiet', '--force', self.lv_snap)

        return False

def backup_dir (name, dir):
    target_dir = os.path.join (config.get ('target', 'dir'), config.get ('target', 'subdir'), name)

    if not os.path.exists (target_dir):
        os.makedirs (target_dir)

    if backup_type == 'dummy':
        return
    
    args = ['duplicity',
        '--exclude-other-filesystems']

    if backup_type == 'auto':
        args.extend (['--full-if-older-than', '1W'])
    else:
        args.append (backup_type)

    args.extend ([dir, urlparse.urljoin ('file:', target_dir)])
    call (*args)

def backup_lv (name, section):
    with snapshot (config.get (section, 'what')) as s:
        with mount (s.device, config.get ('lvm', 'snapshot_mnt'), ro = True):
            backup_dir (name, config.get ('lvm', 'snapshot_mnt'))

def print_line (msg):
    print '_____ %s %s' % (msg, '_' * (67 - len (msg) - 1))

if __name__ == '__main__':
    backup_types = ['auto', 'full', 'incremental', 'dummy']
    if (len (sys.argv) != 3):
        print >> sys.stderr, "Usage: %s CONFIGFILE %s" % (sys.argv[0], '|'.join (backup_types))
        sys.exit (1)

    config = ConfigParser.SafeConfigParser ({'hostname': socket.gethostname ()})
    config.read (sys.argv[1])

    # duplicity reads this from the environment
    os.environ['PASSPHRASE'] = config.get ('security', 'passphrase')

    errors = 0

    # full or incremental?
    backup_type = sys.argv[2]
    if sys.argv[2] not in backup_types:
        print 'Invalid backup type "%s"; aborting.' % (sys.argv[2])
        sys.exit (1)

    # run jobs
    with mount (config.get ('target', 'device'), config.get ('target', 'dir'), ro = False, options = config.get ('target', 'options') if config.has_option ('target', 'options') else None):
        job_re = re.compile ('^job:(?P<name>\w+)$')
        for section in config.sections ():
            m = job_re.match (section)
            if m is None: continue

            name = m.group ('name')
            print; print_line ("%s start" % (name))

            try:
                type = config.get (section, 'type')
                if type == 'lv':
                    backup_lv (name, section)
                elif type == 'dir':
                    backup_dir (name, config.get (section, 'what'))
                else:
                    raise Exception ('Unknown job type "%s"' % (type))
            except Exception, e:
                errors += 1
                traceback.print_exc ()
            print_line ("%s end" % (name))

    # report
    print
    print 'Process complete.'

    if errors > 0:
        print '%i job%s failed.' % (errors, errors != 1 and 's' or '')

    with mount (config.get ('target', 'device'), config.get ('target', 'dir'), ro = True) as m:
        # remaining space
        if os.path.ismount (m.target):
            s = os.statvfs (m.target)
            size = s.f_frsize * s.f_blocks
            used = size - s.f_frsize * s.f_bfree
            frac = used/size * 100
            print 'Used %g of %g bytes (%.0f%%).' % (used, size, frac)

    sys.exit (0 if errors == 0 else 1)
