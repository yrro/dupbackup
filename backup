#!/usr/bin/python

from __future__ import division
from __future__ import with_statement

import imp
import os
import subprocess
import sys
import traceback
import time
import urlparse

config = imp.load_source ('config', '/etc/backup.conf')

def call (*args, **kwargs):
    print '>', ' '.join (args)

    kwargs['stdout'] = subprocess.PIPE
    kwargs['stderr'] = subprocess.STDOUT
    kwargs['close_fds'] = True
    p = subprocess.Popen (args, **kwargs)

    so, se = p.communicate ()
    for line in so.split ('\n'):
        if line!='': print '|', line
    if p.returncode != 0:
        raise Exception ('%s failed (status %i)' % (args[0], p.returncode))

class mount (object):
    def __init__ (self, device, target, ro = True):
        self.device = device
        self.target = target
        self.ro = ro

        if os.path.ismount (target):
            raise Exception ('"%s" already mounted' % (target))

    def __enter__ (self):
        call ('mount',
            '-o',
            'ro' if self.ro else 'rw',
            self.device,
            self.target)

        return self

    def __exit__ (self, exc_type, exc_val, exc_tb):
        if not os.path.ismount (self.target):
            raise Exception ('"%s" no longer mounted' % (self.target))
        call ('umount', self.target)

        return False

class snapshot (object):
    def __init__ (self, lv):
        self.lv = lv
        self.lv_snap = '%s_backup' % (lv)
        self.device = os.path.join ('/dev', self.lv_snap)

    def __enter__ (self):
        call ('lvcreate', '--quiet', '--size=1G', '--snapshot', '--name=%s' % (self.lv_snap), self.lv)

        return self

    def __exit__ (self, exc_type, exc_val, exc_tv):
        call ('lvremove', '--quiet', '--force', self.lv_snap)

        return False

def backup_dir (name, dir):
    target_dir = os.path.join (config.target_mnt, date, name)

    if fi == 'full':
        os.makedirs (target_dir)
    
    call ('duplicity',
        fi,
        '--exclude-other-filesystems',
        dir,
        urlparse.urljoin ('file:', target_dir))

def backup_lv (name, lv):
    with snapshot (lv) as s:
        with mount (s.device, config.snapshot_mnt, ro = True):
            backup_dir (name, config.snapshot_mnt)

if __name__ == '__main__':
    # duplicity reads this from the environment
    os.environ['PASSPHRASE'] = config.passphrase

    date = time.strftime ('%G-%V')

    errors = 0

    # full or incremental?
    if len (sys.argv) != 2:
        print 'Backup type not specified; aborting.'
        sys.exit (1)
    fi = sys.argv[1]
    if sys.argv[1] not in ('full', 'incremental'):
        print 'Invalid backup type "%s"; aborting.' % (sys.argv[1])
        sys.exit (1)

    # run jobs
    with mount (config.target_device, config.target_mnt, ro = False):
        for job in config.jobs:
            print '_' * 72
            print
            print 'Backing up "%s"...' % (job['name'])

            try:
                if job['type'] == 'lv':
                    backup_lv (job['name'], job['what'])
                elif job['type'] == 'dir':
                    backup_dir (job['name'], job['what'])
                else:
                    raise Exception ('Unknown job type "%s"' % (job['type']))
            except Exception, e:
                errors += 1
                traceback.print_exc ()

    # report
    print '_' * 72
    print
    print 'Process complete.'

    if errors > 0:
        print '%i job%s failed.' % (errors, errors != 1 and 's' or '')

    with mount (config.target_device, config.target_mnt, ro = True) as m:
        # remaining space
        if os.path.ismount (m.target):
            s = os.statvfs (m.target)
            size = s.f_frsize * s.f_blocks
            used = size - s.f_frsize * s.f_bfree
            frac = used/size * 100
            print 'Used %g of %g bytes (%.0f%%).' % (used, size, frac)

    sys.exit (0 if errors == 0 else 1)
